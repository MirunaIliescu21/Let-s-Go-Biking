using Newtonsoft.Json;
using RoutingServiceREST.ProxyRef;  // Connected Service → ProxyCacheService
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.ServiceModel.Web;
using static RoutingServiceREST.ItineraryResponse;
using RoutingServiceREST.Services;

namespace RoutingServiceREST
{
    public class RoutingService : IRoutingServiceREST
    {
        // Default constructor for production usage
        public RoutingService() { }

        // For tests / DI
        public RoutingService(ProxyRef.ProxyServiceClient proxy) => _proxy = proxy;

        private readonly ProxyRef.ProxyServiceClient _proxy = null;

        private static void AllowCors()
        {
            var r = WebOperationContext.Current?.OutgoingResponse;
            if (r == null) return;
            r.Headers.Add("Access-Control-Allow-Origin", "*");
            r.Headers.Add("Access-Control-Allow-Headers", "content-type");
            r.Headers.Add("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        }

        // Public API: thin coordinator that delegates heavy work to the helper internals
        public ItineraryResponse GetItinerary(ItineraryRequest request)
        {
            AllowCors();
            if (request == null || string.IsNullOrWhiteSpace(request.Origin) || string.IsNullOrWhiteSpace(request.Destination))
                return Fail("Origin/Destination is missing.");

            try
            {
                using (var proxy = _proxy ?? new ProxyServiceClient())
                {
                    // Geocode if needed
                    if (request.OriginLat == 0 && request.OriginLon == 0)
                    {
                        if (!TryGeocode(request.Origin, proxy, out var olat, out var olon))
                            return Fail("Could not geocode Origin address.");
                        request.OriginLat = olat; request.OriginLon = olon;
                    }
                    if (request.DestLat == 0 && request.DestLon == 0)
                    {
                        if (!TryGeocode(request.Destination, proxy, out var dlat, out var dlon))
                            return Fail("Could not geocode Destination address.");
                        request.DestLat = dlat; request.DestLon = dlon;
                    }

                    // Load stations and delegate planning
                    var stationProvider = new ProxyStationProvider(proxy);
                    var allStations = stationProvider.LoadAllStations();

                    var planner = new RoutePlanner();
                    return planner.PlanBest(request, allStations, proxy);
                }
            }
            catch (Exception ex)
            {
                return Fail($"Error: {ex.Message}");
            }
        }

        public void Options() => AllowCors();
        public string Ping() { AllowCors(); return "pong"; }

        public List<JcDecauxContract> GetContracts()
        {
            AllowCors();
            using (var proxy = new ProxyRef.ProxyServiceClient())
            {
                string url = "https://api.jcdecaux.com/vls/v3/contracts";
                string json = proxy.GetWithTtl(url, 3600, false, false);
                var trimmed = json?.TrimStart() ?? "";

                if (string.IsNullOrEmpty(trimmed))
                    throw new Exception("JCDecaux empty response.");

                if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                    throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

                try
                {
                    var contracts = JsonConvert.DeserializeObject<List<JcDecauxContract>>(json) ?? new List<JcDecauxContract>();
                    foreach (var c in contracts) if (c.Cities == null) c.Cities = new List<string>();
                    return contracts;
                }
                catch (Exception ex)
                {
                    throw new Exception("Parse error (contracts): " + ex.Message);
                }
            }
        }

        public List<JcdecauxStation> GetStations(string contract)
        {
            AllowCors();
            using (var proxy = new ProxyRef.ProxyServiceClient())
            {
                string baseUrl = "https://api.jcdecaux.com/vls/v3/stations";
                string url = string.IsNullOrWhiteSpace(contract) ? $"{baseUrl}" : $"{baseUrl}?contract={Uri.EscapeDataString(contract)}";

                string json = proxy.GetWithTtl(url, 60, false, false);
                var trimmed = json?.TrimStart() ?? "";

                if (string.IsNullOrEmpty(trimmed)) throw new Exception("JCDecaux empty response.");
                if (trimmed.StartsWith("<") || trimmed.StartsWith("(")) throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

                try { return JsonConvert.DeserializeObject<List<JcdecauxStation>>(json); }
                catch (Exception ex) { throw new Exception("Parse error (stations): " + ex.Message); }
            }
        }

        private static ItineraryResponse Fail(string msg) => new ItineraryResponse { Success = false, Message = msg, Instructions = Array.Empty<string>() };

        // --- INTERNAL / REFACTORED HELPERS (kept as static to minimize changes) ---
        // These mirror the original code but are callable from the new planner/provider classes.

        internal static JcdecauxStation FindClosestStationInternal(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations.OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon)).FirstOrDefault();
        }

        internal static ItineraryResponse PlanIntercityBikeAtOriginInternal(ItineraryRequest req, string originContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            // reuse original implementation by delegating to instance method
            var service = new RoutingService(proxy);
            return service.PlanIntercityBikeAtOrigin(req, originContract, allStations, proxy);
        }

        internal static ItineraryResponse PlanIntercityBikeAtDestinationInternal(ItineraryRequest req, string destContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.PlanIntercityBikeAtDestination(req, destContract, allStations, proxy);
        }

        internal static ItineraryResponse PlanIntercityBikeBothEndsInternal(ItineraryRequest req, string originContract, string destContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.PlanIntercityBikeBothEnds(req, originContract, destContract, allStations, proxy);
        }

        internal static OrsRoute GetORSRouteInternal(string profile, double startLon, double startLat, double endLon, double endLat, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.GetORSRoute(profile, startLon, startLat, endLon, endLat, proxy);
        }

        internal static ItineraryResponse BuildWalkOnlyPlanInternal(ItineraryRequest req, ProxyRef.ProxyServiceClient proxy, string reason)
        {
            var service = new RoutingService(proxy);
            return service.BuildWalkOnlyPlan(req, proxy, reason);
        }

        internal static ItineraryResponse PlanWithinSameNetworkInternal(ItineraryRequest req, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy, JcdecauxStation nearestToOrigin, JcdecauxStation nearestToDest)
        {
            var service = new RoutingService(proxy);
            // reuse big block from original code: filter stations, pick top candidates and compute ORS routes
            return service.PlanWithinSameNetwork(req, allStations, proxy, nearestToOrigin, nearestToDest);
        }

        // Keep original implementations as instance/private methods so internals can call them.
        //// Proximity thresholds (tunable
        //private const double MAX_NETWORK_RADIUS_KM = 5.0;   // minimum to say "there is network coverage nearby"
        //private const double MAX_ORIGIN_RADIUS_KM = 1.2;    // max distance you'll walk to the pickup station
        //private const double MAX_DEST_RADIUS_KM = 1.2;      // max distance you'll walk from the drop-off station
        //private const double MAX_INTERCITY_KM = 30.0;       // max distance between nearest origin and destination stations

        //// "No-network" thresholds: if no useful stations exist, pick walking only if it's still reasonable
        //private const double MAX_WALK_SECONDS_NO_NETWORK = 1800; // 30 min
        //private const double MAX_WALK_KM_NO_NETWORK = 3.0;  // ~3 km

        // Plan 1: bike only in ORIGIN contract (walk at the end to Destination)
        // This method builds an itinerary where the bike segment is entirely within
        // the origin city's JCDecaux contract. It returns null if suitable stations
        // (with bikes at pickup and stands at drop) are not available.
        private ItineraryResponse PlanIntercityBikeAtOrigin(
            ItineraryRequest req,
            string originContract,
            List<JcdecauxStation> allStations,
            ProxyRef.ProxyServiceClient proxy)
        {
            var originStations = allStations.Where(s =>
                string.Equals(s.ContractName, originContract, StringComparison.OrdinalIgnoreCase)).ToList();

            var pickup = FindClosestStationWithBikes(originStations, req.OriginLat, req.OriginLon);
            var drop = FindWithStandsNearestTo(originStations, req.DestLat, req.DestLon);
            if (pickup == null || drop == null)
                return null;

            var walk1 = GetORSRoute("foot-walking",
                req.OriginLon, req.OriginLat, pickup.Position.Lon, pickup.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular",
                pickup.Position.Lon, pickup.Position.Lat, drop.Position.Lon, drop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking",
                drop.Position.Lon, drop.Position.Lat, req.DestLon, req.DestLat, proxy);

            var resp = new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = new[]
                {
                    $"Start point: {req.Origin}",
                    $"End point: {req.Destination}",
                    $"Origin contract: {originContract}",
                    $"Walk to station '{pickup.Name}'.",
                    $"Ride to station '{drop.Name}'.",
                    $"Walk to the destination."
                },
                UseBike = true,
                OriginContract = originContract,
                DestContract = null,
                BikeFrom = pickup.Name,
                BikeTo = drop.Name,

                WalkOnlyDurationSec = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy).DurationSec,
                BikePlanDurationSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec,

                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,

                Walk1DistanceMeters = walk1.DistanceMeters,
                BikeDistanceMeters = bike.DistanceMeters,
                Walk2DistanceMeters = walk2.DistanceMeters,

                BikePlanDistanceMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters,

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon
            };
            return resp;
        }

        // Plan2: bike only in DEST contract (long walk into the city, then bike + short final walk)
        // Similar to PlanIntercityBikeAtOrigin but uses the destination contract for biking.
        private ItineraryResponse PlanIntercityBikeAtDestination(
            ItineraryRequest req,
            string destContract,
            List<JcdecauxStation> allStations,
            ProxyRef.ProxyServiceClient proxy)
        {
            var destStations = allStations.Where(s =>
                string.Equals(s.ContractName, destContract, StringComparison.OrdinalIgnoreCase)).ToList();

            // enter in city: take the first station in the destination contract that is "nearest to Origin"
            var pickup = FindWithBikesNearestTo(destStations, req.OriginLat, req.OriginLon);
            // closest station to Destination with stands available
            var drop = FindWithStandsNearestTo(destStations, req.DestLat, req.DestLon);
            if (pickup == null || drop == null)
                return null;

            var walk1 = GetORSRoute("foot-walking",
                req.OriginLon, req.OriginLat, pickup.Position.Lon, pickup.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular",
                pickup.Position.Lon, pickup.Position.Lat, drop.Position.Lon, drop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking",
                drop.Position.Lon, drop.Position.Lat, req.DestLon, req.DestLat, proxy);

            var resp = new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = new[]
                {
                    $"Start point: {req.Origin}",
                    $"End point: {req.Destination}",
                    $"Destination contract: {destContract}",
                    $"Walk to station '{pickup.Name}' (first station in the destination network).",
                    $"Ride to station '{drop.Name}'.",
                    $"Walk to the destination."
                },
                UseBike = true,
                OriginContract = null,
                DestContract = destContract,
                BikeFrom = pickup.Name,
                BikeTo = drop.Name,

                WalkOnlyDurationSec = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy).DurationSec,
                BikePlanDurationSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec,

                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,

                Walk1DistanceMeters = walk1.DistanceMeters,
                BikeDistanceMeters = bike.DistanceMeters,
                Walk2DistanceMeters = walk2.DistanceMeters,

                BikePlanDistanceMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters,

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon
            };
            return resp;
        }

        // Always build a full walk-only itinerary when bike is not feasible/available.
        // This returns a COMPLETE ItineraryResponse with route coords so the UI
        // can render the walking path on a map.
        private ItineraryResponse BuildWalkOnlyPlan(ItineraryRequest req, ProxyRef.ProxyServiceClient proxy, string reason)
        {
            // 1) Get walking route from ORS so we have distance, duration, and a polyline for the map
            var walk = GetORSRoute(
                "foot-walking",
                req.OriginLon, req.OriginLat,
                req.DestLon, req.DestLat,
                proxy);

            var steps = new List<string>
            {
                $"Start point: {req.Origin}",
                $"End point: {req.Destination}",
                string.IsNullOrWhiteSpace(reason)
                    ? "There is no useful JCDecaux network in the area."
                    : reason,
                "Walk to the destination (bike is not feasible in this scenario)."
            };

            // 2) Return a COMPLETE response so debug/UI can render the path
            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP complet OK",
                Instructions = steps.ToArray(),

                UseBike = false,
                OriginContract = null,
                DestContract = null,
                BikeFrom = null,
                BikeTo = null,

                WalkOnlyDurationSec = Math.Round(walk.DurationSec, 1),
                BikePlanDurationSec = 0,

                WalkOnlyDistanceMeters = Math.Round(walk.DistanceMeters, 1),
                BikePlanDistanceMeters = 0,

                Walk1Coords = walk.Coords,   // draw this on the map
                BikeCoords = null,
                Walk2Coords = null,

                Walk1DistanceMeters = Math.Round(walk.DistanceMeters, 1),
                BikeDistanceMeters = 0,
                Walk2DistanceMeters = 0,

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon,

                BikeFromTop3 = null,
                BikeToTop3 = null
            };
        }

        private static double HaversineKm(double lat1, double lon1, double lat2, double lon2)
        {
            const double R = 6371.0;
            double dLat = (lat2 - lat1) * Math.PI / 180.0;
            double dLon = (lon2 - lon1) * Math.PI / 180.0;
            double a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                       Math.Cos(lat1 * Math.PI / 180.0) * Math.Cos(lat2 * Math.PI / 180.0) *
                       Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
            double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            return R * c;
        }

        private static double HaversineMeters(double lat1, double lon1, double lat2, double lon2)
        {
            return HaversineKm(lat1, lon1, lat2, lon2) * 1000.0;
        }

        // Function used to prefer "city" results in geocoding.
        // The name has only one word, without "," or numbers etc. - it looks ambiguase
        private static bool IsLikelyCityQuery(string s)
        {
            if (string.IsNullOrWhiteSpace(s)) return false;
            if (s.IndexOf(',') >= 0) return false;           // "Lyon, France" is clear, we don't do anything
            if (s.Any(char.IsDigit)) return false;           // "221B Baker Street" is clear, we don't do anything
            var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            return parts.Length <= 3;                         // It's only a short name (e.g. "Lyon", "New York")
        }

        // Geocodare ORS (forward) — city-first
        // This method prefers locality-like results when the query looks like a city name.
        private static bool TryGeocode(string text, ProxyServiceClient proxy, out double lat, out double lon)
        {
            lat = 0; lon = 0;
            if (string.IsNullOrWhiteSpace(text)) return false;

            string baseUrl = "https://api.openrouteservice.org/geocode/search";
            bool cityMode = IsLikelyCityQuery(text);

            // City-first mode: layers=locality,localadmin,county,region,macroregion
            string url = $"{baseUrl}?text={Uri.EscapeDataString(text)}&size=1" +
                         (cityMode ? "&layers=locality,localadmin,county,region,macroregion" : "");

            string json = proxy.GetWithTtl(url, 86400, false, false);
            var trimmed = json?.TrimStart() ?? "";
            if (string.IsNullOrEmpty(trimmed))
                throw new Exception("ORS geocode empty response.");
            if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                throw new Exception("ORS geocode non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            dynamic doc = JsonConvert.DeserializeObject(json);
            if (doc?.features == null || doc.features.Count == 0)
            {
                // fallback: generic search 
                if (cityMode)
                {
                    url = $"{baseUrl}?text={Uri.EscapeDataString(text)}&size=1";
                    json = proxy.GetWithTtl(url, 86400, false, false);
                    trimmed = json?.TrimStart() ?? "";
                    if (string.IsNullOrEmpty(trimmed)) return false;
                    if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                        throw new Exception("ORS geocode non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));
                    doc = JsonConvert.DeserializeObject(json);
                }
                if (doc?.features == null || doc.features.Count == 0) return false;
            }

            double dlon = (double)doc.features[0].geometry.coordinates[0];
            double dlat = (double)doc.features[0].geometry.coordinates[1];
            lat = dlat; lon = dlon;
            return true;
        }

        // ORS Directions (duration + optional steps)
        // This method parses ORS JSON and returns a compact OrsRoute with
        // duration, distance, a list of human-readable steps and coordinates
        private class OrsRoute
        {
            public double DurationSec { get; set; }
            public double DistanceMeters { get; set; }
            public List<string> Steps { get; set; } = new List<string>();
            public List<double[]> Coords { get; set; } = new List<double[]>(); // [lat, lon]
        }

        private static OrsRoute GetORSRoute(
            string profile,
            double startLon, double startLat, double endLon, double endLat,
            ProxyServiceClient proxy)
        {
            string url =
                $"https://api.openrouteservice.org/v2/directions/{profile}" +
                $"?start={startLon.ToString(CultureInfo.InvariantCulture)},{startLat.ToString(CultureInfo.InvariantCulture)}" +
                $"&end={endLon.ToString(CultureInfo.InvariantCulture)},{endLat.ToString(CultureInfo.InvariantCulture)}";

            string json = proxy.GetWithTtl(url, 120, false, false);
            var trimmed = json?.TrimStart() ?? "";

            if (string.IsNullOrEmpty(trimmed))
                throw new Exception("ORS directions empty response.");

            if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                throw new Exception("ORS directions non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            dynamic doc = JsonConvert.DeserializeObject(json);
            var seg = doc.features[0].properties.segments[0];

            double dur = (double)seg.duration;   // seconds
            double dist = (double)seg.distance;  // meters


            var steps = new List<string>();
            foreach (var s in doc.features[0].properties.segments[0].steps)
            {
                string instr = (string)s.instruction;
                if (!string.IsNullOrWhiteSpace(instr))
                {
                    steps.Add(instr);
                }
            }

            var coords = new List<double[]>();
            foreach (var p in doc.features[0].geometry.coordinates)
            {
                double lon = (double)p[0];
                double lat = (double)p[1];
                coords.Add(new[] { lat, lon }); // [lat,lon] for Leaflet
            }


            return new OrsRoute { DurationSec = dur, DistanceMeters = dist, Steps = steps, Coords = coords };
        }

        private static ItineraryResponse.RouteSegment Seg(string mode, string contract,
                                                          string fromName, string toName, OrsRoute r)
        {
            return new ItineraryResponse.RouteSegment
            {
                Mode = mode,
                Contract = contract,
                FromName = fromName,
                ToName = toName,
                Coords = r?.Coords ?? new List<double[]>(),
                DistanceMeters = r?.DistanceMeters ?? 0,
                DurationSec = r?.DurationSec ?? 0
            };
        }

        // Bike both ends (long walk between cities)
        // This plan is used when both origin and destination networks can provide
        // a bike segment on each city and a long inter-city walk/transfer exists.
        private ItineraryResponse PlanIntercityBikeBothEnds(
            ItineraryRequest req,
            string originContract,
            string destContract,
            List<JcdecauxStation> allStations,
            ProxyRef.ProxyServiceClient proxy)
        {
            // 1) stații din contractul de origine
            var originStations = allStations.Where(s =>
                string.Equals(s.ContractName, originContract, StringComparison.OrdinalIgnoreCase)).ToList();

            // 2) stații din contractul de destinație
            var destStations = allStations.Where(s =>
                string.Equals(s.ContractName, destContract, StringComparison.OrdinalIgnoreCase)).ToList();

            // ——— ORIGIN SIDE ———
            var oPickup = FindClosestStationWithBikes(originStations, req.OriginLat, req.OriginLon);
            // “ieșire” din orașul de origine: cea mai aproape de coordonatele destinației
            var oDrop = FindWithStandsNearestTo(originStations, req.DestLat, req.DestLon);

            // ——— DEST SIDE ———
            // “intrare” în orașul de destinație: cea mai aproape de coordonatele originii
            var dPickup = FindWithBikesNearestTo(destStations, req.OriginLat, req.OriginLon);
            var dDrop = FindWithStandsNearestTo(destStations, req.DestLat, req.DestLon);

            // dacă nu avem măcar câte o pereche validă la ambele capete → renunțăm la acest plan
            if (oPickup == null || oDrop == null || dPickup == null || dDrop == null)
                return null;

            // ——— segmente rulate la ORS ———
            var walk0 = GetORSRoute("foot-walking",
                req.OriginLon, req.OriginLat, oPickup.Position.Lon, oPickup.Position.Lat, proxy);

            var bike0 = GetORSRoute("cycling-regular",
                oPickup.Position.Lon, oPickup.Position.Lat, oDrop.Position.Lon, oDrop.Position.Lat, proxy);

            // mers “inter-city” între capete (poate fi lung; profu’ a cerut să existe rută oricum)
            var walkMid = GetORSRoute("foot-walking",
                oDrop.Position.Lon, oDrop.Position.Lat, dPickup.Position.Lon, dPickup.Position.Lat, proxy);

            var bike1 = GetORSRoute("cycling-regular",
                dPickup.Position.Lon, dPickup.Position.Lat, dDrop.Position.Lon, dDrop.Position.Lat, proxy);

            var walk2 = GetORSRoute("foot-walking",
                dDrop.Position.Lon, dDrop.Position.Lat, req.DestLon, req.DestLat, proxy);

            // totaluri
            double bikePlanSec = walk0.DurationSec + bike0.DurationSec + walkMid.DurationSec + bike1.DurationSec + walk2.DurationSec;
            double bikePlanMeters = walk0.DistanceMeters + bike0.DistanceMeters + walkMid.DistanceMeters + bike1.DistanceMeters + walk2.DistanceMeters;

            var walkOnly = GetORSRoute("foot-walking",
                req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy);

            bool useBike = bikePlanSec + 60 < walkOnly.DurationSec;

            // Instrucțiuni
            var steps = new List<string>
                    {
                        $"Start point: {req.Origin}",
                        $"End point: {req.Destination}",
                        "The origin and destination are in different JCDecaux networks (inter-city).",
                        $"Origin contract: {originContract}",
                        $"Destination contract: {destContract}"
                    };
            steps.Add($"Walk to station '{oPickup.Name}'.");
            steps.Add($"Ride to station '{oDrop.Name}'.");
            steps.Add($"Walk (inter-city) to station '{dPickup.Name}'.");
            steps.Add($"Ride to station '{dDrop.Name}'.");
            steps.Add("Walk to the destination.");

            var resp = new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK — both-ends bike",
                Instructions = steps.ToArray(),
                UseBike = useBike,

                // păstrăm câmpurile clasice cu niște valori reprezentative
                OriginContract = originContract,
                DestContract = destContract,
                BikeFrom = oPickup.Name,
                BikeTo = dDrop.Name,

                WalkOnlyDurationSec = Math.Round(walkOnly.DurationSec, 1),
                BikePlanDurationSec = Math.Round(bikePlanSec, 1),

                // pentru compat (UI vechi), punem doar primul bike în BikeCoords;
                // restul traseului e în Segments (nou)
                Walk1Coords = walk0.Coords,
                BikeCoords = bike0.Coords,
                Walk2Coords = walk2.Coords,

                WalkOnlyDistanceMeters = Math.Round(walkOnly.DistanceMeters, 1),
                BikePlanDistanceMeters = Math.Round(bikePlanMeters, 1),
                Walk1DistanceMeters = Math.Round(walk0.DistanceMeters, 1),
                BikeDistanceMeters = Math.Round(bike0.DistanceMeters, 1),
                Walk2DistanceMeters = Math.Round(walk2.DistanceMeters, 1),

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon,

                Segments = new List<ItineraryResponse.RouteSegment>
                {
                    Seg("walk", null, "Origin", oPickup.Name, walk0),
                    Seg("bike", originContract, oPickup.Name, oDrop.Name, bike0),
                    Seg("walk", null, oDrop.Name, dPickup.Name, walkMid),
                    Seg("bike", destContract, dPickup.Name, dDrop.Name, bike1),
                    Seg("walk", null, dDrop.Name, "Destination", walk2)
                }
            };

            return resp;
        }
    }
}

