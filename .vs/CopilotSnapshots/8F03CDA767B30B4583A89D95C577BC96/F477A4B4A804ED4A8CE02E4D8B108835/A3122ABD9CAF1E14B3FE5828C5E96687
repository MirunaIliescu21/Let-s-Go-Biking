using Newtonsoft.Json;
using RoutingServiceREST.ProxyRef;  // Connected Service → ProxyCacheService
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.ServiceModel.Web;
using static RoutingServiceREST.ItineraryResponse;
using RoutingServiceREST.Services;

namespace RoutingServiceREST
{
    public class RoutingService : IRoutingServiceREST
    {
        // Default constructor for production usage
        public RoutingService() { }

        // For tests / DI
        public RoutingService(ProxyRef.ProxyServiceClient proxy) => _proxy = proxy;

        private readonly ProxyRef.ProxyServiceClient _proxy = null;

        private static void AllowCors()
        {
            var r = WebOperationContext.Current?.OutgoingResponse;
            if (r == null) return;
            r.Headers.Add("Access-Control-Allow-Origin", "*");
            r.Headers.Add("Access-Control-Allow-Headers", "content-type");
            r.Headers.Add("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        }

        // Public API: thin coordinator that delegates heavy work to the helper internals
        public ItineraryResponse GetItinerary(ItineraryRequest request)
        {
            AllowCors();
            if (request == null || string.IsNullOrWhiteSpace(request.Origin) || string.IsNullOrWhiteSpace(request.Destination))
                return Fail("Origin/Destination is missing.");

            try
            {
                using (var proxy = _proxy ?? new ProxyServiceClient())
                {
                    // Geocode if needed
                    if (request.OriginLat == 0 && request.OriginLon == 0)
                    {
                        if (!TryGeocode(request.Origin, proxy, out var olat, out var olon))
                            return Fail("Could not geocode Origin address.");
                        request.OriginLat = olat; request.OriginLon = olon;
                    }
                    if (request.DestLat == 0 && request.DestLon == 0)
                    {
                        if (!TryGeocode(request.Destination, proxy, out var dlat, out var dlon))
                            return Fail("Could not geocode Destination address.");
                        request.DestLat = dlat; request.DestLon = dlon;
                    }

                    // Load stations and delegate planning
                    var stationProvider = new ProxyStationProvider(proxy);
                    var allStations = stationProvider.LoadAllStations();

                    var planner = new RoutePlanner();
                    return planner.PlanBest(request, allStations, proxy);
                }
            }
            catch (Exception ex)
            {
                return Fail($"Error: {ex.Message}");
            }
        }

        public void Options() => AllowCors();
        public string Ping() { AllowCors(); return "pong"; }

        public List<JcDecauxContract> GetContracts()
        {
            AllowCors();
            using (var proxy = new ProxyRef.ProxyServiceClient())
            {
                string url = "https://api.jcdecaux.com/vls/v3/contracts";
                string json = proxy.GetWithTtl(url, 3600, false, false);
                var trimmed = json?.TrimStart() ?? "";

                if (string.IsNullOrEmpty(trimmed))
                    throw new Exception("JCDecaux empty response.");

                if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                    throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

                try
                {
                    var contracts = JsonConvert.DeserializeObject<List<JcDecauxContract>>(json) ?? new List<JcDecauxContract>();
                    foreach (var c in contracts) if (c.Cities == null) c.Cities = new List<string>();
                    return contracts;
                }
                catch (Exception ex)
                {
                    throw new Exception("Parse error (contracts): " + ex.Message);
                }
            }
        }

        public List<JcdecauxStation> GetStations(string contract)
        {
            AllowCors();
            using (var proxy = new ProxyRef.ProxyServiceClient())
            {
                string baseUrl = "https://api.jcdecaux.com/vls/v3/stations";
                string url = string.IsNullOrWhiteSpace(contract) ? $"{baseUrl}" : $"{baseUrl}?contract={Uri.EscapeDataString(contract)}";

                string json = proxy.GetWithTtl(url, 60, false, false);
                var trimmed = json?.TrimStart() ?? "";

                if (string.IsNullOrEmpty(trimmed)) throw new Exception("JCDecaux empty response.");
                if (trimmed.StartsWith("<") || trimmed.StartsWith("(")) throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

                try { return JsonConvert.DeserializeObject<List<JcdecauxStation>>(json); }
                catch (Exception ex) { throw new Exception("Parse error (stations): " + ex.Message); }
            }
        }

        private static ItineraryResponse Fail(string msg) => new ItineraryResponse { Success = false, Message = msg, Instructions = Array.Empty<string>() };

        // --- INTERNAL / REFACTORED HELPERS (kept as static to minimize changes) ---
        // These mirror the original code but are callable from the new planner/provider classes.

        public static JcdecauxStation FindClosestStationInternal(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations.OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon)).FirstOrDefault();
        }

        public static ItineraryResponse PlanIntercityBikeAtOriginInternal(ItineraryRequest req, string originContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.PlanIntercityBikeAtOrigin(req, originContract, allStations, proxy);
        }

        public static ItineraryResponse PlanIntercityBikeAtDestinationInternal(ItineraryRequest req, string destContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.PlanIntercityBikeAtDestination(req, destContract, allStations, proxy);
        }

        public static ItineraryResponse PlanIntercityBikeBothEndsInternal(ItineraryRequest req, string originContract, string destContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.PlanIntercityBikeBothEnds(req, originContract, destContract, allStations, proxy);
        }

        public static OrsRoute GetORSRouteInternal(string profile, double startLon, double startLat, double endLon, double endLat, ProxyRef.ProxyServiceClient proxy)
        {
            var service = new RoutingService(proxy);
            return service.GetORSRoute(profile, startLon, startLat, endLon, endLat, proxy);
        }

        public static ItineraryResponse BuildWalkOnlyPlanInternal(ItineraryRequest req, ProxyRef.ProxyServiceClient proxy, string reason)
        {
            var service = new RoutingService(proxy);
            return service.BuildWalkOnlyPlan(req, proxy, reason);
        }

        public static ItineraryResponse PlanWithinSameNetworkInternal(ItineraryRequest req, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy, JcdecauxStation nearestToOrigin, JcdecauxStation nearestToDest)
        {
            var service = new RoutingService(proxy);
            return service.PlanWithinSameNetwork(req, allStations, proxy, nearestToOrigin, nearestToDest);
        }

        // ORS Directions return type used across the assembly
        public class OrsRoute
        {
            public double DurationSec { get; set; }
            public double DistanceMeters { get; set; }
            public List<string> Steps { get; set; } = new List<string>();
            public List<double[]> Coords { get; set; } = new List<double[]>();
        }

        private OrsRoute GetORSRoute(string profile, double startLon, double startLat, double endLon, double endLat, ProxyRef.ProxyServiceClient proxy)
        {
            string url = $"https://api.openrouteservice.org/v2/directions/{profile}" +
                         $"?start={startLon.ToString(CultureInfo.InvariantCulture)},{startLat.ToString(CultureInfo.InvariantCulture)}" +
                         $"&end={endLon.ToString(CultureInfo.InvariantCulture)},{endLat.ToString(CultureInfo.InvariantCulture)}";

            string json = proxy.GetWithTtl(url, 120, false, false);
            var trimmed = json?.TrimStart() ?? "";
            if (string.IsNullOrEmpty(trimmed)) throw new Exception("ORS directions empty response.");
            if (trimmed.StartsWith("<") || trimmed.StartsWith("(")) throw new Exception("ORS directions non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            dynamic doc = JsonConvert.DeserializeObject(json);
            var seg = doc.features[0].properties.segments[0];
            double dur = (double)seg.duration;
            double dist = (double)seg.distance;

            var steps = new List<string>();
            foreach (var s in doc.features[0].properties.segments[0].steps)
            {
                string instr = (string)s.instruction;
                if (!string.IsNullOrWhiteSpace(instr)) steps.Add(instr);
            }

            var coords = new List<double[]>();
            foreach (var p in doc.features[0].geometry.coordinates)
            {
                double lon = (double)p[0]; double lat = (double)p[1]; coords.Add(new[] { lat, lon });
            }

            return new OrsRoute { DurationSec = dur, DistanceMeters = dist, Steps = steps, Coords = coords };
        }

        private static ItineraryResponse.RouteSegment Seg(string mode, string contract, string fromName, string toName, OrsRoute r)
        {
            return new ItineraryResponse.RouteSegment
            {
                Mode = mode,
                Contract = contract,
                FromName = fromName,
                ToName = toName,
                Coords = r?.Coords ?? new List<double[]>(),
                DistanceMeters = r?.DistanceMeters ?? 0,
                DurationSec = r?.DurationSec ?? 0
            };
        }

        // Core planning pieces moved back into instance methods for reuse
        private ItineraryResponse PlanWithinSameNetwork(ItineraryRequest request, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy, JcdecauxStation nearestToOrigin, JcdecauxStation nearestToDest)
        {
            string originContract = nearestToOrigin.ContractName;
            string destContract = nearestToDest.ContractName;

            var contracts = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { originContract, destContract };
            var stations = allStations.Where(s => contracts.Contains(s.ContractName)).ToList();

            var fromCandidates = stations
                .Where(s => (s.TotalStands?.Availabilities?.Bikes ?? 0) > 0)
                .Select(s => new { S = s, DistM = HaversineMeters(request.OriginLat, request.OriginLon, s.Position.Lat, s.Position.Lon) })
                .OrderBy(x => x.DistM)
                .Take(3).ToList();

            var toCandidates = stations
                .Where(s => (s.TotalStands?.Availabilities?.Stands ?? 0) > 0)
                .Select(s => new { S = s, DistM = HaversineMeters(request.DestLat, request.DestLon, s.Position.Lat, s.Position.Lon) })
                .OrderBy(x => x.DistM)
                .Take(3).ToList();

            var bikeFrom = fromCandidates.OrderBy(x => x.DistM).ThenBy(x => x.S.Name).FirstOrDefault()?.S;
            var bikeTo = toCandidates.OrderBy(x => x.DistM).ThenBy(x => x.S.Name).FirstOrDefault()?.S;

            if (bikeFrom == null || bikeTo == null) return BuildWalkOnlyPlan(request, proxy, "No bikes near us.");

            var walkOnly = GetORSRoute("foot-walking", request.OriginLon, request.OriginLat, request.DestLon, request.DestLat, proxy);
            var walk1 = GetORSRoute("foot-walking", request.OriginLon, request.OriginLat, bikeFrom.Position.Lon, bikeFrom.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular", bikeFrom.Position.Lon, bikeFrom.Position.Lat, bikeTo.Position.Lon, bikeTo.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking", bikeTo.Position.Lon, bikeTo.Position.Lat, request.DestLon, request.DestLat, proxy);

            double walkOnlySec = walkOnly.DurationSec;
            double bikePlanSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec;
            bool useBike = bikePlanSec + 60 < walkOnlySec;

            double walkOnlyMeters = walkOnly.DistanceMeters;
            double bikePlanMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters;

            var steps = new List<string>
            {
                $"Start point: {request.Origin}",
                $"End point: {request.Destination}",
                $"Origin contract: {originContract}",
                $"Destination contract: {destContract}"
            };
            if (useBike)
            {
                steps.Add($"Walk to station '{bikeFrom.Name}'.");
                steps.Add($"Pick up a bike and ride to station '{bikeTo.Name}'.");
                steps.Add($"Drop the bike and walk to the destination.");
            }
            else
            {
                steps.Add("Walk to the destination (bike does not provide significant benefit).");
            }

            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = steps.ToArray(),
                UseBike = useBike,
                OriginContract = originContract,
                DestContract = destContract,
                BikeFrom = bikeFrom.Name,
                BikeTo = bikeTo.Name,
                WalkOnlyDurationSec = Math.Round(walkOnlySec, 1),
                BikePlanDurationSec = Math.Round(bikePlanSec, 1),
                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,
                WalkOnlyDistanceMeters = Math.Round(walkOnlyMeters, 1),
                BikePlanDistanceMeters = Math.Round(bikePlanMeters, 1),
                Walk1DistanceMeters = Math.Round(walk1.DistanceMeters, 1),
                BikeDistanceMeters = Math.Round(bike.DistanceMeters, 1),
                Walk2DistanceMeters = Math.Round(walk2.DistanceMeters, 1),
                OriginResolvedLat = request.OriginLat,
                OriginResolvedLon = request.OriginLon,
                DestResolvedLat = request.DestLat,
                DestResolvedLon = request.DestLon
            };
        }

        private ItineraryResponse BuildWalkOnlyPlan(ItineraryRequest req, ProxyRef.ProxyServiceClient proxy, string reason)
        {
            var walk = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy);
            var steps = new List<string>
            {
                $"Start point: {req.Origin}",
                $"End point: {req.Destination}",
                string.IsNullOrWhiteSpace(reason) ? "There is no useful JCDecaux network in the area." : reason,
                "Walk to the destination (bike is not feasible in this scenario)."
            };

            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP complet OK",
                Instructions = steps.ToArray(),
                UseBike = false,
                OriginContract = null,
                DestContract = null,
                BikeFrom = null,
                BikeTo = null,
                WalkOnlyDurationSec = Math.Round(walk.DurationSec, 1),
                BikePlanDurationSec = 0,
                WalkOnlyDistanceMeters = Math.Round(walk.DistanceMeters, 1),
                BikePlanDistanceMeters = 0,
                Walk1Coords = walk.Coords,
                BikeCoords = null,
                Walk2Coords = null,
                Walk1DistanceMeters = Math.Round(walk.DistanceMeters, 1),
                BikeDistanceMeters = 0,
                Walk2DistanceMeters = 0,
                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon,
                BikeFromTop3 = null,
                BikeToTop3 = null
            };
        }

        private ItineraryResponse PlanIntercityBikeAtOrigin(ItineraryRequest req, string originContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var originStations = allStations.Where(s => string.Equals(s.ContractName, originContract, StringComparison.OrdinalIgnoreCase)).ToList();
            var pickup = FindClosestStationWithBikes(originStations, req.OriginLat, req.OriginLon);
            var drop = FindWithStandsNearestTo(originStations, req.DestLat, req.DestLon);
            if (pickup == null || drop == null) return null;

            var walk1 = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, pickup.Position.Lon, pickup.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular", pickup.Position.Lon, pickup.Position.Lat, drop.Position.Lon, drop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking", drop.Position.Lon, drop.Position.Lat, req.DestLon, req.DestLat, proxy);

            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = new[] { $"Start point: {req.Origin}", $"End point: {req.Destination}", $"Origin contract: {originContract}", $"Walk to station '{pickup.Name}'.", $"Ride to station '{drop.Name}'.", $"Walk to the destination." },
                UseBike = true,
                OriginContract = originContract,
                DestContract = null,
                BikeFrom = pickup.Name,
                BikeTo = drop.Name,
                WalkOnlyDurationSec = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy).DurationSec,
                BikePlanDurationSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec,
                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,
                Walk1DistanceMeters = walk1.DistanceMeters,
                BikeDistanceMeters = bike.DistanceMeters,
                Walk2DistanceMeters = walk2.DistanceMeters,
                BikePlanDistanceMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters,
                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon
            };
        }

        private ItineraryResponse PlanIntercityBikeAtDestination(ItineraryRequest req, string destContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var destStations = allStations.Where(s => string.Equals(s.ContractName, destContract, StringComparison.OrdinalIgnoreCase)).ToList();
            var pickup = FindWithBikesNearestTo(destStations, req.OriginLat, req.OriginLon);
            var drop = FindWithStandsNearestTo(destStations, req.DestLat, req.DestLon);
            if (pickup == null || drop == null) return null;

            var walk1 = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, pickup.Position.Lon, pickup.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular", pickup.Position.Lon, pickup.Position.Lat, drop.Position.Lon, drop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking", drop.Position.Lon, drop.Position.Lat, req.DestLon, req.DestLat, proxy);

            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = new[] { $"Start point: {req.Origin}", $"End point: {req.Destination}", $"Destination contract: {destContract}", $"Walk to station '{pickup.Name}' (first station in the destination network).", $"Ride to station '{drop.Name}'.", $"Walk to the destination." },
                UseBike = true,
                OriginContract = null,
                DestContract = destContract,
                BikeFrom = pickup.Name,
                BikeTo = drop.Name,
                WalkOnlyDurationSec = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy).DurationSec,
                BikePlanDurationSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec,
                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,
                Walk1DistanceMeters = walk1.DistanceMeters,
                BikeDistanceMeters = bike.DistanceMeters,
                Walk2DistanceMeters = walk2.DistanceMeters,
                BikePlanDistanceMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters,
                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon
            };
        }

        private ItineraryResponse PlanIntercityBikeBothEnds(ItineraryRequest req, string originContract, string destContract, List<JcdecauxStation> allStations, ProxyRef.ProxyServiceClient proxy)
        {
            var originStations = allStations.Where(s => string.Equals(s.ContractName, originContract, StringComparison.OrdinalIgnoreCase)).ToList();
            var destStations = allStations.Where(s => string.Equals(s.ContractName, destContract, StringComparison.OrdinalIgnoreCase)).ToList();

            var oPickup = FindClosestStationWithBikes(originStations, req.OriginLat, req.OriginLon);
            var oDrop = FindWithStandsNearestTo(originStations, req.DestLat, req.DestLon);
            var dPickup = FindWithBikesNearestTo(destStations, req.OriginLat, req.OriginLon);
            var dDrop = FindWithStandsNearestTo(destStations, req.DestLat, req.DestLon);

            if (oPickup == null || oDrop == null || dPickup == null || dDrop == null) return null;

            var walk0 = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, oPickup.Position.Lon, oPickup.Position.Lat, proxy);
            var bike0 = GetORSRoute("cycling-regular", oPickup.Position.Lon, oPickup.Position.Lat, oDrop.Position.Lon, oDrop.Position.Lat, proxy);
            var walkMid = GetORSRoute("foot-walking", oDrop.Position.Lon, oDrop.Position.Lat, dPickup.Position.Lon, dPickup.Position.Lat, proxy);
            var bike1 = GetORSRoute("cycling-regular", dPickup.Position.Lon, dPickup.Position.Lat, dDrop.Position.Lon, dDrop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking", dDrop.Position.Lon, dDrop.Position.Lat, req.DestLon, req.DestLat, proxy);

            double bikePlanSec = walk0.DurationSec + bike0.DurationSec + walkMid.DurationSec + bike1.DurationSec + walk2.DurationSec;
            double bikePlanMeters = walk0.DistanceMeters + bike0.DistanceMeters + walkMid.DistanceMeters + bike1.DistanceMeters + walk2.DistanceMeters;

            var walkOnly = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy);
            bool useBike = bikePlanSec + 60 < walkOnly.DurationSec;

            var steps = new List<string>
            {
                $"Start point: {req.Origin}",
                $"End point: {req.Destination}",
                "The origin and destination are in different JCDecaux networks (inter-city).",
                $"Origin contract: {originContract}",
                $"Destination contract: {destContract}"
            };
            steps.Add($"Walk to station '{oPickup.Name}'.");
            steps.Add($"Ride to station '{oDrop.Name}'.");
            steps.Add($"Walk (inter-city) to station '{dPickup.Name}'.");
            steps.Add($"Ride to station '{dDrop.Name}'.");
            steps.Add("Walk to the destination.");

            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK — both-ends bike",
                Instructions = steps.ToArray(),
                UseBike = useBike,
                OriginContract = originContract,
                DestContract = destContract,
                BikeFrom = oPickup.Name,
                BikeTo = dDrop.Name,
                WalkOnlyDurationSec = Math.Round(walkOnly.DurationSec, 1),
                BikePlanDurationSec = Math.Round(bikePlanSec, 1),
                Walk1Coords = walk0.Coords,
                BikeCoords = bike0.Coords,
                Walk2Coords = walk2.Coords,
                WalkOnlyDistanceMeters = Math.Round(walkOnly.DistanceMeters, 1),
                BikePlanDistanceMeters = Math.Round(bikePlanMeters, 1),
                Walk1DistanceMeters = Math.Round(walk0.DistanceMeters, 1),
                BikeDistanceMeters = Math.Round(bike0.DistanceMeters, 1),
                Walk2DistanceMeters = Math.Round(walk2.DistanceMeters, 1),
                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon,
                Segments = new List<ItineraryResponse.RouteSegment>
                {
                    Seg("walk", null, "Origin", oPickup.Name, walk0),
                    Seg("bike", originContract, oPickup.Name, oDrop.Name, bike0),
                    Seg("walk", null, oDrop.Name, dPickup.Name, walkMid),
                    Seg("bike", destContract, dPickup.Name, dDrop.Name, bike1),
                    Seg("walk", null, dDrop.Name, "Destination", walk2)
                }
            };
        }

        private static List<JcdecauxStation> LoadAllStationsViaProxyInternal(ProxyRef.ProxyServiceClient proxy)
        {
            string url = "https://api.jcdecaux.com/vls/v3/stations";
            string json = proxy.GetWithTtl(url, 60, false, false);
            return JsonConvert.DeserializeObject<List<JcdecauxStation>>(json);
        }

        private static JcdecauxStation FindClosestStation(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations.OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon)).FirstOrDefault();
        }

        private static JcdecauxStation FindClosestStationWithBikes(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations.Where(s => (s.TotalStands?.Availabilities?.Bikes ?? 0) > 0).OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon)).FirstOrDefault();
        }

        private static JcdecauxStation FindWithBikesNearestTo(IEnumerable<JcdecauxStation> stations, double targetLat, double targetLon)
        {
            return stations.Where(s => (s.TotalStands?.Availabilities?.Bikes ?? 0) > 0).OrderBy(s => HaversineKm(targetLat, targetLon, s.Position.Lat, s.Position.Lon)).FirstOrDefault();
        }

        private static JcdecauxStation FindWithStandsNearestTo(IEnumerable<JcdecauxStation> stations, double targetLat, double targetLon)
        {
            return stations.Where(s => (s.TotalStands?.Availabilities?.Stands ?? 0) > 0).OrderBy(s => HaversineKm(targetLat, targetLon, s.Position.Lat, s.Position.Lon)).FirstOrDefault();
        }
    }
}

