using Newtonsoft.Json;
using RoutingServiceREST.ProxyRef;  // Connected Service → ProxyCacheService
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.ServiceModel.Web;
using static RoutingServiceREST.ItineraryResponse;

namespace RoutingServiceREST
{
    public class RoutingService : IRoutingServiceREST
    {
        // Proximity thresholds (tunable
        private const double MAX_NETWORK_RADIUS_KM = 5.0;   // minimum to say "there is network coverage nearby"
        private const double MAX_ORIGIN_RADIUS_KM = 1.2;    // max distance you'll walk to the pickup station
        private const double MAX_DEST_RADIUS_KM = 1.2;      // max distance you'll walk from the drop-off station
        private const double MAX_INTERCITY_KM = 30.0;       // max distance between nearest origin and destination stations

        // "No-network" thresholds: if no useful stations exist, pick walking only if it's still reasonable
        private const double MAX_WALK_SECONDS_NO_NETWORK = 1800; // 30 min
        private const double MAX_WALK_KM_NO_NETWORK = 3.0;  // ~3 km

        private static void AllowCors()
        {
            var r = WebOperationContext.Current?.OutgoingResponse;
            if (r == null) return;
            r.Headers.Add("Access-Control-Allow-Origin", "*");
            r.Headers.Add("Access-Control-Allow-Headers", "content-type");
            r.Headers.Add("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        }

        // Plan 1: bike doar în ORIGIN contract (walk la final până la Destination)
        private ItineraryResponse PlanIntercityBikeAtOrigin(
            ItineraryRequest req,
            string originContract,
            List<JcdecauxStation> allStations,
            ProxyRef.ProxyServiceClient proxy)
        {
            var originStations = allStations.Where(s =>
                string.Equals(s.ContractName, originContract, StringComparison.OrdinalIgnoreCase)).ToList();

            var pickup = FindClosestStationWithBikes(originStations, req.OriginLat, req.OriginLon);
            var drop = FindWithStandsNearestTo(originStations, req.DestLat, req.DestLon);
            if (pickup == null || drop == null)
                return null;

            var walk1 = GetORSRoute("foot-walking",
                req.OriginLon, req.OriginLat, pickup.Position.Lon, pickup.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular",
                pickup.Position.Lon, pickup.Position.Lat, drop.Position.Lon, drop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking",
                drop.Position.Lon, drop.Position.Lat, req.DestLon, req.DestLat, proxy);

            var resp = new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = new[]
                {
                    $"Start point: {req.Origin}",
                    $"End point: {req.Destination}",
                    $"Origin contract: {originContract}",
                    $"Walk to station '{pickup.Name}'.",
                    $"Ride to station '{drop.Name}'.",
                    $"Walk to the destination."
                },
                UseBike = true,
                OriginContract = originContract,
                DestContract = null,
                BikeFrom = pickup.Name,
                BikeTo = drop.Name,

                WalkOnlyDurationSec = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy).DurationSec,
                BikePlanDurationSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec,

                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,

                Walk1DistanceMeters = walk1.DistanceMeters,
                BikeDistanceMeters = bike.DistanceMeters,
                Walk2DistanceMeters = walk2.DistanceMeters,

                BikePlanDistanceMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters,

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon
            };
            return resp;
        }

        // Plan 2: bike doar în DEST contract (walk lung până în oraș, apoi bike + walk scurt final)
        private ItineraryResponse PlanIntercityBikeAtDestination(
            ItineraryRequest req,
            string destContract,
            List<JcdecauxStation> allStations,
            ProxyRef.ProxyServiceClient proxy)
        {
            var destStations = allStations.Where(s =>
                string.Equals(s.ContractName, destContract, StringComparison.OrdinalIgnoreCase)).ToList();

            // intrare în oraș: ia prima stație din contractul de destinație care e "cel mai aproape de Origin"
            var pickup = FindWithBikesNearestTo(destStations, req.OriginLat, req.OriginLon);
            // ieșire bike: stația cea mai apropiată de adresa finală
            var drop = FindWithStandsNearestTo(destStations, req.DestLat, req.DestLon);
            if (pickup == null || drop == null)
                return null;

            var walk1 = GetORSRoute("foot-walking",
                req.OriginLon, req.OriginLat, pickup.Position.Lon, pickup.Position.Lat, proxy);
            var bike = GetORSRoute("cycling-regular",
                pickup.Position.Lon, pickup.Position.Lat, drop.Position.Lon, drop.Position.Lat, proxy);
            var walk2 = GetORSRoute("foot-walking",
                drop.Position.Lon, drop.Position.Lat, req.DestLon, req.DestLat, proxy);

            var resp = new ItineraryResponse
            {
                Success = true,
                Message = "MVP OK",
                Instructions = new[]
                {
                    $"Start point: {req.Origin}",
                    $"End point: {req.Destination}",
                    $"Destination contract: {destContract}",
                    $"Walk to station '{pickup.Name}' (first station in the destination network).",
                    $"Ride to station '{drop.Name}'.",
                    $"Walk to the destination."
                },
                UseBike = true,
                OriginContract = null,
                DestContract = destContract,
                BikeFrom = pickup.Name,
                BikeTo = drop.Name,

                WalkOnlyDurationSec = GetORSRoute("foot-walking", req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy).DurationSec,
                BikePlanDurationSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec,

                Walk1Coords = walk1.Coords,
                BikeCoords = bike.Coords,
                Walk2Coords = walk2.Coords,

                Walk1DistanceMeters = walk1.DistanceMeters,
                BikeDistanceMeters = bike.DistanceMeters,
                Walk2DistanceMeters = walk2.DistanceMeters,

                BikePlanDistanceMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters,

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon
            };
            return resp;
        }

        public ItineraryResponse GetItinerary(ItineraryRequest request)
        {
            AllowCors();
            if (request == null || string.IsNullOrWhiteSpace(request.Origin) || string.IsNullOrWhiteSpace(request.Destination))
                return Fail("Origin/Destination is missing.");

            try
            {
                using (var proxy = new ProxyServiceClient())
                {
                    // GEOCODING (ORS) – staged, with clear messages
                    try
                    {
                        if ((request.OriginLat == 0 && request.OriginLon == 0))
                        {
                            if (!TryGeocode(request.Origin, proxy, out var olat, out var olon))
                                return Fail("Could not geocode Origin address..");
                            request.OriginLat = olat;
                            request.OriginLon = olon;
                        }
                    }
                    catch (Exception ex)
                    {
                        return Fail("ORS geocoding error (Origin): " + ex.Message);
                    }

                    try
                    {
                        if ((request.DestLat == 0 && request.DestLon == 0))
                        {
                            if (!TryGeocode(request.Destination, proxy, out var dlat, out var dlon))
                                return Fail("Could not geocode Destionation address.");
                            request.DestLat = dlat;
                            request.DestLon = dlon;
                        }
                    }
                    catch (Exception ex)
                    {
                        return Fail("ORS geocoding error (Destination): " + ex.Message);
                    }


                    // Smart disambiguation for Destination: pull it closer to Origin if it landed too far
                    try
                    {
                        double straightKm = HaversineKm(request.OriginLat, request.OriginLon, request.DestLat, request.DestLon);

                        // If destination is very far and seems ambiguous, retry within the origin's radius
                        if (straightKm > 50 && LooksAmbiguous(request.Destination))
                        {
                            // Search within ~80 km from Origin
                            if (TryGeocodeNear(request.Destination, request.OriginLat, request.OriginLon, 80000,
                                               proxy, out var dlat2, out var dlon2))
                            {
                                double straightKm2 = HaversineKm(request.OriginLat, request.OriginLon, dlat2, dlon2);
                                if (straightKm2 < straightKm)
                                {
                                    request.DestLat = dlat2;
                                    request.DestLon = dlon2;
                                    straightKm = straightKm2;
                                }
                            }

                            // If still too far, try minimal textual context (e.g., "<dest>, <origin>")
                            if (straightKm > 50)
                            {
                                var candidate = $"{request.Destination}, {request.Origin}";
                                if (TryGeocode(candidate, proxy, out var dlat3, out var dlon3))
                                {
                                    double straightKm3 = HaversineKm(request.OriginLat, request.OriginLon, dlat3, dlon3);
                                    if (straightKm3 < straightKm)
                                    {
                                        request.DestLat = dlat3;
                                        request.DestLon = dlon3;
                                        straightKm = straightKm3;
                                    }
                                }
                            }
                        }
                    }
                    catch { /* non-fatal: continue with what we already have */ }

                    // Adding info for debugging
                    var resp = new ItineraryResponse();
                    resp.OriginResolvedLat = request.OriginLat;
                    resp.OriginResolvedLon = request.OriginLon;
                    resp.DestResolvedLat = request.DestLat;
                    resp.DestResolvedLon = request.DestLon;

                    // JCDECAUX – list stations
                    List<JcdecauxStation> allStations;
                    try
                    {
                        allStations = LoadAllStationsViaProxy(proxy);
                        if (allStations == null || allStations.Count == 0)
                            //return DecideWalkOrFail(request, proxy,
                            //    "JCDecaux API returned no stations for this area.");
                            return BuildWalkOnlyPlan(request, proxy, "There is no useful JCDecaux network in the area.");

                    }
                    catch (Exception ex)
                    {
                        return BuildWalkOnlyPlan(request, proxy,
                            "JCDecaux load error: " + ex.Message);
                    }

                    // Find the closest stations from any contract
                    var nearestToOrigin = FindClosestStation(allStations, request.OriginLat, request.OriginLon);
                    var nearestToDest = FindClosestStation(allStations, request.DestLat, request.DestLon);
                    if (nearestToOrigin == null || nearestToDest == null)
                        return BuildWalkOnlyPlan(request, proxy,
                            "No nearby JCDecaux stations were found.");

                    // Proximity checks
                    double distNetOriginKm = HaversineKm(request.OriginLat, request.OriginLon,
                                                         nearestToOrigin.Position.Lat, nearestToOrigin.Position.Lon);
                    double distNetDestKm = HaversineKm(request.DestLat, request.DestLon,
                                                         nearestToDest.Position.Lat, nearestToDest.Position.Lon);

                    // If there is no reasonable nearby network: walk-or-fail decision
                    if (distNetOriginKm > MAX_NETWORK_RADIUS_KM || distNetDestKm > MAX_NETWORK_RADIUS_KM)
                        return BuildWalkOnlyPlan(request, proxy,
                            "There is no useful JCDecaux network in the area.");

                    // Inter-city (different contracts): walk-or-fail
                    double nearestStationsDistanceKm = HaversineKm(nearestToOrigin.Position.Lat, nearestToOrigin.Position.Lon,
                                                                   nearestToDest.Position.Lat, nearestToDest.Position.Lon);
                    //if (!string.Equals(nearestToOrigin.ContractName, nearestToDest.ContractName, StringComparison.OrdinalIgnoreCase)
                    //    && nearestStationsDistanceKm > MAX_INTERCITY_KM)
                    //{
                    //    return BuildWalkOnlyPlan(request, proxy,
                    //        "The origin and destination are different in JCDecaux networks (inter-city).");
                    //}

                    // Inter-city (different contracts): try best single-side bike plan (origin or destination)
                    bool differentContracts = !string.Equals(nearestToOrigin.ContractName, nearestToDest.ContractName, StringComparison.OrdinalIgnoreCase);

                    if (differentContracts)
                    {
                        string originContract = nearestToOrigin.ContractName;
                        string destContract = nearestToDest.ContractName;

                        // Încearcă cele două opțiuni
                        var planOriginSide = PlanIntercityBikeAtOrigin(request, originContract, allStations, proxy);
                        var planDestSide = PlanIntercityBikeAtDestination(request, destContract, allStations, proxy);

                        // dacă ambele au eșuat (nu se găsesc stații cu bikes/stands), arată măcar walk-only complet
                        if (planOriginSide == null && planDestSide == null)
                            return BuildWalkOnlyPlan(request, proxy, "The origin and destination are in different JCDecaux networks (inter-city).");

                        // Alege planul cu durată totală mai mică (sau, dacă vrei, distanță)
                        ItineraryResponse best =
                            (planOriginSide != null && planDestSide != null)
                            ? (planOriginSide.BikePlanDurationSec <= planDestSide.BikePlanDurationSec ? planOriginSide : planDestSide)
                            : (planOriginSide ?? planDestSide);

                        // Completează și un mic context
                        var steps = best.Instructions.ToList();
                        steps.Insert(2, "The origin and destination are in different JCDecaux networks (inter-city).");
                        best.Instructions = steps.ToArray();
                        return best;
                    }


                    // It's possible to have a relevant network
                    string originContract = nearestToOrigin.ContractName;
                    string destContract = nearestToDest.ContractName;

                    // Filter stations by relevant contracts
                    var contracts = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                    { originContract, destContract };
                    var stations = allStations.Where(s => contracts.Contains(s.ContractName)).ToList();

                    // Stations near Origin that have stands available, sorted in ascending order
                    var fromCandidates = stations
                        .Where(s => (s.TotalStands?.Availabilities?.Bikes ?? 0) > 0)
                        .Select(s => new
                        {
                            S = s,
                            DistM = HaversineMeters(request.OriginLat, request.OriginLon, s.Position.Lat, s.Position.Lon)
                        })
                        .OrderBy(x => x.DistM)
                        .Take(3)
                        .ToList();      // take the first 3 closest ones

                    // Stations near Destianation that have stands available, sorted in ascending order
                    var toCandidates = stations
                        .Where(s => (s.TotalStands?.Availabilities?.Stands ?? 0) > 0)
                        .Select(s => new
                        {
                            S = s,
                            DistM = HaversineMeters(request.DestLat, request.DestLon, s.Position.Lat, s.Position.Lon)
                        })
                        .OrderBy(x => x.DistM)
                        .Take(3)
                        .ToList();      // take the first 3 closest ones

                    // The winning stations
                    var bikeFrom = fromCandidates.OrderBy(x => x.DistM).ThenBy(x => x.S.Name).FirstOrDefault()?.S;
                    var bikeTo = toCandidates.OrderBy(x => x.DistM).ThenBy(x => x.S.Name).FirstOrDefault()?.S;

                    if (bikeFrom == null || bikeTo == null)
                        return BuildWalkOnlyPlan(request, proxy, "No bikes near us.");

                    // If the user requests debug, I populate the top-3 station in the response
                    if (request.Debug)
                    {
                        resp.BikeFromTop3 = fromCandidates.Select(x => new DebugStationChoice
                        {
                            Name = x.S.Name,
                            Lat = x.S.Position.Lat,
                            Lon = x.S.Position.Lon,
                            Bikes = x.S.TotalStands?.Availabilities?.Bikes ?? 0,
                            Stands = x.S.TotalStands?.Availabilities?.Stands ?? 0,
                            DistanceMeters = Math.Round(x.DistM, 1)
                        }).ToList();

                        resp.BikeToTop3 = toCandidates.Select(x => new DebugStationChoice
                        {
                            Name = x.S.Name,
                            Lat = x.S.Position.Lat,
                            Lon = x.S.Position.Lon,
                            Bikes = x.S.TotalStands?.Availabilities?.Bikes ?? 0,
                            Stands = x.S.TotalStands?.Availabilities?.Stands ?? 0,
                            DistanceMeters = Math.Round(x.DistM, 1)
                        }).ToList();
                    }
                    // Stop debug

                    // Compare walk-only vs bike plan (ORS durations)
                    var walkOnly = GetORSRoute("foot-walking",
                        request.OriginLon, request.OriginLat, request.DestLon, request.DestLat, proxy);

                    var walk1 = GetORSRoute("foot-walking",
                        request.OriginLon, request.OriginLat, bikeFrom.Position.Lon, bikeFrom.Position.Lat, proxy);
                    var bike = GetORSRoute("cycling-regular",
                        bikeFrom.Position.Lon, bikeFrom.Position.Lat, bikeTo.Position.Lon, bikeTo.Position.Lat, proxy);
                    var walk2 = GetORSRoute("foot-walking",
                        bikeTo.Position.Lon, bikeTo.Position.Lat, request.DestLon, request.DestLat, proxy);

                    // Distance guards (not just durations)
                    double walkToPickupKm = HaversineKm(request.OriginLat, request.OriginLon,
                                                        bikeFrom.Position.Lat, bikeFrom.Position.Lon);
                    double walkFromDropKm = HaversineKm(bikeTo.Position.Lat, bikeTo.Position.Lon,
                                                        request.DestLat, request.DestLon);

                    if (walkToPickupKm > MAX_ORIGIN_RADIUS_KM || walkFromDropKm > MAX_DEST_RADIUS_KM)
                        return BuildWalkOnlyPlan(request, proxy,
                            "The useful stations are too far away for a bike route");

                    // Calculate durations by foot and by bike and compare them
                    double walkOnlySec = walkOnly.DurationSec;
                    double bikePlanSec = walk1.DurationSec + bike.DurationSec + walk2.DurationSec;

                    bool useBike = bikePlanSec + 60 < walkOnlySec; // small buffer (1 min) for lock/unlock etc.

                    double walkOnlyMeters = walkOnly.DistanceMeters;
                    double bikePlanMeters = walk1.DistanceMeters + bike.DistanceMeters + walk2.DistanceMeters;

                    // Instructions
                    var steps = new List<string>
                    {
                        $"Start point: {request.Origin}",
                        $"End point: {request.Destination}",
                        $"Origin contract: {originContract}",
                        $"Destination contract: {destContract}"
                    };

                    if (useBike)
                    {
                        steps.Add($"Walk to station '{bikeFrom.Name}'.");
                        steps.Add($"Pick up a bike and ride to station '{bikeTo.Name}'.");
                        steps.Add($"Drop the bike and walk to the destination.");
                    }
                    else
                    {
                        steps.Add("Walk to the destination (bike does not provide significant benefit).");
                    }

                    resp.Success = true;
                    resp.Message = "MVP OK";
                    resp.Instructions = steps.ToArray();
                    resp.UseBike = useBike;
                    resp.OriginContract = originContract;
                    resp.DestContract = destContract;
                    resp.BikeFrom = bikeFrom.Name;
                    resp.BikeTo = bikeTo.Name;
                    resp.WalkOnlyDurationSec = Math.Round(walkOnlySec, 1);
                    resp.BikePlanDurationSec = Math.Round(bikePlanSec, 1);
                    resp.Walk1Coords = walk1.Coords;
                    resp.BikeCoords = bike.Coords;
                    resp.Walk2Coords = walk2.Coords;
                    resp.WalkOnlyDistanceMeters = Math.Round(walkOnlyMeters, 1);
                    resp.BikePlanDistanceMeters = Math.Round(bikePlanMeters, 1);
                    resp.Walk1DistanceMeters = Math.Round(walk1.DistanceMeters, 1);
                    resp.BikeDistanceMeters = Math.Round(bike.DistanceMeters, 1);
                    resp.Walk2DistanceMeters = Math.Round(walk2.DistanceMeters, 1);
                    return resp;

                }
            }
            catch (Exception ex)
            {
                return Fail($"Error: {ex.Message}");
            }
        }

        public void Options() => AllowCors();

        public string Ping()
        {
            AllowCors();
            return "pong";
        }

        public List<JcDecauxContract> GetContracts()
        {
            AllowCors();
            using (var proxy = new ProxyRef.ProxyServiceClient())
            {
                string url = "https://api.jcdecaux.com/vls/v3/contracts";
                string json = proxy.GetWithTtl(url, 3600, false, false);
                var trimmed = json?.TrimStart() ?? "";

                if (string.IsNullOrEmpty(trimmed))
                    throw new Exception("JCDecaux empty response.");

                if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                    throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

                try
                {
                    // Deserialize directly into typed objects
                    var contracts = JsonConvert.DeserializeObject<List<JcDecauxContract>>(json)
                                    ?? new List<JcDecauxContract>();

                    // Normalize null lists for safer usage later
                    foreach (var c in contracts)
                    {
                        if (c.Cities == null)
                        {
                            c.Cities = new List<string>();
                        }
                    }

                    return contracts;
                }
                catch (Exception ex)
                {
                    throw new Exception("Parse error (contracts): " + ex.Message);
                }
            }
        }


        public List<JcdecauxStation> GetStations(string contract)
        {
            AllowCors();
            using (var proxy = new ProxyRef.ProxyServiceClient())
            {
                string baseUrl = "https://api.jcdecaux.com/vls/v3/stations";
                string url = string.IsNullOrWhiteSpace(contract)
                    ? $"{baseUrl}"
                    : $"{baseUrl}?contract={Uri.EscapeDataString(contract)}";


                string json = proxy.GetWithTtl(url, 60, false, false);
                var trimmed = json?.TrimStart() ?? "";

                if (string.IsNullOrEmpty(trimmed))
                    throw new Exception("JCDecaux empty response.");

                if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                    throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

                try
                {
                    return JsonConvert.DeserializeObject<List<JcdecauxStation>>(json);
                }
                catch (Exception ex)
                {
                    throw new Exception("Parse error (stations): " + ex.Message);
                }
            }
        }


        private static ItineraryResponse Fail(string msg) => new ItineraryResponse
        {
            Success = false,
            Message = msg,
            Instructions = Array.Empty<string>()
        };

        // consider ambiguous if there's no comma/country and the term is short (e.g., "Louvre")
        private static bool LooksAmbiguous(string s)
        {
            if (string.IsNullOrWhiteSpace(s)) return true;
            if (s.Contains(",")) return false;
            var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            return parts.Length <= 3;
        }

        // Geocoding with a focus on an area (around the origin)
        private static bool TryGeocodeNear(
            string text,
            double focusLat, double focusLon,
            int radiusMeters,
            ProxyServiceClient proxy,
            out double lat, out double lon)
        {
            lat = 0; lon = 0;
            if (string.IsNullOrWhiteSpace(text)) return false;

            // ORS/Pelias: focus.point + boundary.circle limit the results
            string url =
                "https://api.openrouteservice.org/geocode/search" +
                $"?text={Uri.EscapeDataString(text)}&size=1" +
                $"&focus.point.lat={focusLat.ToString(CultureInfo.InvariantCulture)}" +
                $"&focus.point.lon={focusLon.ToString(CultureInfo.InvariantCulture)}" +
                $"&boundary.circle.lat={focusLat.ToString(CultureInfo.InvariantCulture)}" +
                $"&boundary.circle.lon={focusLon.ToString(CultureInfo.InvariantCulture)}" +
                $"&boundary.circle.radius={radiusMeters}";

            string json = proxy.GetWithTtl(url, 3600, false, false);
            var trimmed = json?.TrimStart() ?? "";
            if (string.IsNullOrEmpty(trimmed)) return false;
            if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                throw new Exception("ORS geocode (near) non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            dynamic doc = JsonConvert.DeserializeObject(json);
            if (doc?.features == null || doc.features.Count == 0) return false;

            double dlon = (double)doc.features[0].geometry.coordinates[0];
            double dlat = (double)doc.features[0].geometry.coordinates[1];
            lat = dlat; lon = dlon;
            return true;
        }


        //// Decide when to walk or return Fail, based on thresholds
        //private ItineraryResponse BuildWalkOnlyPlan(ItineraryRequest req, ProxyServiceClient proxy, string why)
        //{
        //    var walk = GetORSRoute("foot-walking",
        //        req.OriginLon, req.OriginLat, req.DestLon, req.DestLat, proxy);

        //    var straightKm = HaversineKm(req.OriginLat, req.OriginLon, req.DestLat, req.DestLon);

        //    if (walk.DurationSec <= MAX_WALK_SECONDS_NO_NETWORK || straightKm <= MAX_WALK_KM_NO_NETWORK)
        //    {
        //        var steps = new List<string>
        //        {
        //             $"Start point: {req.Origin}",
        //             $"End point: {req.Destination}",
        //             string.IsNullOrWhiteSpace(why)
        //                    ? "No usable JCDecaux network in the area."
        //                    : why,
        //             "Walk to the destination (bike is not feasible in this scenario)."
        //        };

        //        return new ItineraryResponse
        //        {
        //            Success = true,
        //            Message = "MVP complet OK",
        //            Instructions = steps.ToArray(),
        //            UseBike = false,
        //            WalkOnlyDurationSec = Math.Round(walk.DurationSec, 1),
        //            BikePlanDurationSec = 0
        //        };
        //    }

        //    var mins = Math.Round(walk.DurationSec / 60.0, 0);
        //    return Fail($"{why} Walking distance is too large (~{mins} min, {straightKm:F1} km). " +
        //        "Cannot propose a bike route in the MVP.");
        //}

        // Decide when to walk or return Fail, based on thresholds
        //private ItineraryResponse BuildWalkOnlyPlan(ItineraryRequest req, ProxyServiceClient proxy, string why)
        //{
        //    // The walk route is needed to decide if walking is acceptable
        //    var walk = GetORSRoute(
        //        "foot-walking",
        //        req.OriginLon, req.OriginLat,
        //        req.DestLon, req.DestLat,
        //        proxy);

        //    var straightKm = HaversineKm(req.OriginLat, req.OriginLon, req.DestLat, req.DestLon);

        //    // If walking is reasonable, build a COMPLETE response (including debug/coords)
        //    if (walk.DurationSec <= MAX_WALK_SECONDS_NO_NETWORK || straightKm <= MAX_WALK_KM_NO_NETWORK)
        //    {
        //        var steps = new List<string>
        //        {
        //            $"Start point: {req.Origin}",
        //            $"End point: {req.Destination}",
        //            string.IsNullOrWhiteSpace(why) ? "No usable JCDecaux network in the area." : why,
        //            "Walk to the destination (bike is not feasible in this scenario)."
        //        };

        //        return new ItineraryResponse
        //        {
        //            Success = true,
        //            Message = "MVP complet OK",
        //            Instructions = steps.ToArray(),

        //            // bike off
        //            UseBike = false,
        //            OriginContract = null,
        //            DestContract = null,
        //            BikeFrom = null,
        //            BikeTo = null,

        //            // metrics & coords
        //            WalkOnlyDurationSec = Math.Round(walk.DurationSec, 1),
        //            BikePlanDurationSec = 0,
        //            WalkOnlyDistanceMeters = Math.Round(walk.DistanceMeters, 1),

        //            // for walk only , we draw the route in Walk1Coords; the others remain null
        //            Walk1Coords = walk.Coords,
        //            BikeCoords = null,
        //            Walk2Coords = null,

        //            Walk1DistanceMeters = Math.Round(walk.DistanceMeters, 1),
        //            BikeDistanceMeters = 0,
        //            Walk2DistanceMeters = 0,
        //            BikePlanDistanceMeters = 0,

        //            // coords for debug
        //            OriginResolvedLat = req.OriginLat,
        //            OriginResolvedLon = req.OriginLon,
        //            DestResolvedLat = req.DestLat,
        //            DestResolvedLon = req.DestLon,

        //            // top3 remain null by design
        //            BikeFromTop3 = null,
        //            BikeToTop3 = null
        //        };
        //    }

        //    // 3) altfel, fallback = Fail explicit, cu motiv + magnitudine
        //    var mins = Math.Round(walk.DurationSec / 60.0, 0);
        //    return Fail($"{why} Walking distance is too large (~{mins} min, {straightKm:F1} km). " +
        //                "Cannot propose a bike route in the MVP.");
        //}

        // Always build a full walk-only itinerary when bike is not feasible/available.
        private ItineraryResponse BuildWalkOnlyPlan(ItineraryRequest req, ProxyRef.ProxyServiceClient proxy, string reason)
        {
            // 1) Get walking route from ORS so we have distance, duration, and a polyline for the map
            var walk = GetORSRoute(
                "foot-walking",
                req.OriginLon, req.OriginLat,
                req.DestLon, req.DestLat,
                proxy);

            var steps = new List<string>
            {
                $"Start point: {req.Origin}",
                $"End point: {req.Destination}",
                string.IsNullOrWhiteSpace(reason)
                    ? "There is no useful JCDecaux network in the area."
                    : reason,
                "Walk to the destination (bike is not feasible in this scenario)."
            };

            // 2) Return a COMPLETE response so debug/UI can render the path
            return new ItineraryResponse
            {
                Success = true,
                Message = "MVP complet OK",
                Instructions = steps.ToArray(),

                UseBike = false,
                OriginContract = null,
                DestContract = null,
                BikeFrom = null,
                BikeTo = null,

                WalkOnlyDurationSec = Math.Round(walk.DurationSec, 1),
                BikePlanDurationSec = 0,

                WalkOnlyDistanceMeters = Math.Round(walk.DistanceMeters, 1),
                BikePlanDistanceMeters = 0,

                Walk1Coords = walk.Coords,   // draw this on the map
                BikeCoords = null,
                Walk2Coords = null,

                Walk1DistanceMeters = Math.Round(walk.DistanceMeters, 1),
                BikeDistanceMeters = 0,
                Walk2DistanceMeters = 0,

                OriginResolvedLat = req.OriginLat,
                OriginResolvedLon = req.OriginLon,
                DestResolvedLat = req.DestLat,
                DestResolvedLon = req.DestLon,

                BikeFromTop3 = null,
                BikeToTop3 = null
            };
        }



        private static List<JcdecauxStation> LoadAllStationsViaProxy(ProxyServiceClient proxy)
        {
            string url = "https://api.jcdecaux.com/vls/v3/stations";
            string json = proxy.GetWithTtl(url, 60, false, false);
            var trimmed = json?.TrimStart() ?? "";

            if (string.IsNullOrEmpty(trimmed))
                throw new Exception("JCDecaux empty response.");

            if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                throw new Exception("JCDecaux non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            return JsonConvert.DeserializeObject<List<JcdecauxStation>>(json);
        }

        private static JcdecauxStation FindClosestStation(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations
                .OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon))
                .FirstOrDefault();
        }

        private static JcdecauxStation FindClosestStationWithBikes(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations
                .Where(s => (s.TotalStands?.Availabilities?.Bikes ?? 0) > 0)
                .OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon))
                .FirstOrDefault();
        }

        private static JcdecauxStation FindClosestStationWithStands(List<JcdecauxStation> stations, double lat, double lon)
        {
            return stations
                .Where(s => (s.TotalStands?.Availabilities?.Stands ?? 0) > 0)
                .OrderBy(s => HaversineKm(lat, lon, s.Position.Lat, s.Position.Lon))
                .FirstOrDefault();
        }

        private static JcdecauxStation FindWithBikesNearestTo(
            IEnumerable<JcdecauxStation> stations, double targetLat, double targetLon)
        {
            return stations
                .Where(s => (s.TotalStands?.Availabilities?.Bikes ?? 0) > 0)
                .OrderBy(s => HaversineKm(targetLat, targetLon, s.Position.Lat, s.Position.Lon))
                .FirstOrDefault();
        }

        private static JcdecauxStation FindWithStandsNearestTo(
            IEnumerable<JcdecauxStation> stations, double targetLat, double targetLon)
        {
            return stations
                .Where(s => (s.TotalStands?.Availabilities?.Stands ?? 0) > 0)
                .OrderBy(s => HaversineKm(targetLat, targetLon, s.Position.Lat, s.Position.Lon))
                .FirstOrDefault();
        }


        private static double HaversineKm(double lat1, double lon1, double lat2, double lon2)
        {
            const double R = 6371.0;
            double dLat = (lat2 - lat1) * Math.PI / 180.0;
            double dLon = (lon2 - lon1) * Math.PI / 180.0;
            double a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                       Math.Cos(lat1 * Math.PI / 180.0) * Math.Cos(lat2 * Math.PI / 180.0) *
                       Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
            double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            return R * c;
        }

        private static double HaversineMeters(double lat1, double lon1, double lat2, double lon2)
        {
            return HaversineKm(lat1, lon1, lat2, lon2) * 1000.0;
        }


        // Geocodare ORS (forward)
        private static bool TryGeocode(string text, ProxyServiceClient proxy, out double lat, out double lon)
        {
            lat = 0; lon = 0;
            if (string.IsNullOrWhiteSpace(text)) return false;

            string url = $"https://api.openrouteservice.org/geocode/search?text={Uri.EscapeDataString(text)}&size=1";
            string json = proxy.GetWithTtl(url, 86400, false, false);
            var trimmed = json?.TrimStart() ?? "";

            if (string.IsNullOrEmpty(trimmed))
                throw new Exception("ORS geocode empty response.");

            if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                throw new Exception("ORS geocode non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            dynamic doc = JsonConvert.DeserializeObject(json);
            if (doc?.features == null || doc.features.Count == 0) return false;

            double dlon = (double)doc.features[0].geometry.coordinates[0];
            double dlat = (double)doc.features[0].geometry.coordinates[1];
            lat = dlat; lon = dlon;
            return true;
        }

        // ORS Directions (duration + optional steps)
        private class OrsRoute
        {
            public double DurationSec { get; set; }
            public double DistanceMeters { get; set; }
            public List<string> Steps { get; set; } = new List<string>();
            public List<double[]> Coords { get; set; } = new List<double[]>(); // [lat, lon]
        }

        private static OrsRoute GetORSRoute(
            string profile,
            double startLon, double startLat, double endLon, double endLat,
            ProxyServiceClient proxy)
        {
            string url =
                $"https://api.openrouteservice.org/v2/directions/{profile}" +
                $"?start={startLon.ToString(CultureInfo.InvariantCulture)},{startLat.ToString(CultureInfo.InvariantCulture)}" +
                $"&end={endLon.ToString(CultureInfo.InvariantCulture)},{endLat.ToString(CultureInfo.InvariantCulture)}";

            string json = proxy.GetWithTtl(url, 120, false, false);
            var trimmed = json?.TrimStart() ?? "";

            if (string.IsNullOrEmpty(trimmed))
                throw new Exception("ORS directions empty response.");

            if (trimmed.StartsWith("<") || trimmed.StartsWith("("))
                throw new Exception("ORS directions non-JSON: " + trimmed.Substring(0, Math.Min(200, trimmed.Length)));

            dynamic doc = JsonConvert.DeserializeObject(json);
            var seg = doc.features[0].properties.segments[0];

            double dur = (double)seg.duration;   // seconds
            double dist = (double)seg.distance;  // meters
            // double dur = (double)doc.features[0].properties.segments[0].duration;


            var steps = new List<string>();
            foreach (var s in doc.features[0].properties.segments[0].steps)
            {
                string instr = (string)s.instruction;
                if (!string.IsNullOrWhiteSpace(instr))
                {
                    steps.Add(instr);
                }
            }

            var coords = new List<double[]>();
            foreach (var p in doc.features[0].geometry.coordinates)
            {
                double lon = (double)p[0];
                double lat = (double)p[1];
                coords.Add(new[] { lat, lon }); // [lat,lon] for Leaflet
            }


            return new OrsRoute { DurationSec = dur, DistanceMeters = dist, Steps = steps, Coords = coords };
        }
    }
}

