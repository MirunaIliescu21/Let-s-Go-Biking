using ProxyCacheService.Caching;
using System;
using System.Configuration;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Runtime.Caching;
using System.Security.AccessControl;
using System.Web;


namespace ProxyCacheService
{
    public class ProxyService : IProxyService
    {
        private static readonly GenericProxyCache<JcdecauxContractsResource> _contractsCache =
            new GenericProxyCache<JcdecauxContractsResource>();
        private static readonly GenericProxyCache<JcdecauxStationsResource> _stationsCache =
            new GenericProxyCache<JcdecauxStationsResource>();
        private static long _hits = 0;
        private static long _misses = 0;

        // TTL for contracts = 1h
        public string GetJcdecauxContractsGeneric(int ttlSeconds = 3600)
        {
            var item = _contractsCache.Get("jc:contracts", ttlSeconds);
            return item.Content;
        }

        // TTL for stations = 30s
        public string GetJcdecauxStationsGeneric(string contract, int ttlSeconds = 30)
        {
            var key = $"jc:stations:{contract?.Trim().ToLowerInvariant()}";
            var item = _stationsCache.Get(key, ttlSeconds);
            return item.Content;
        }

        private static string AddJcdxKeyIfMissing(string url)
        {
            if (!url.Contains("api.jcdecaux.com")) return url;
            if (url.IndexOf("apiKey=", StringComparison.OrdinalIgnoreCase) >= 0) return url;

            var k = ConfigurationManager.AppSettings["JCDECAUX_API_KEY"] ?? "";
            if (string.IsNullOrEmpty(k)) return url; // don’t break if missing

            var sep = url.Contains("?") ? "&" : "?";
            return url + sep + "apiKey=" + Uri.EscapeDataString(k);
        }

        //private HttpGetResource GetOrCreate(string rawUrl, DateTimeOffset expiration, bool forceRefresh = false, bool extendTtl = false)
        //{
        //    // normalize URL (inject JCDecaux key if needed)
        //    var url = AddJcdxKeyIfMissing(rawUrl);

        //    var cache = MemoryCache.Default;
        //    var key = $"GET::{url}";

        //    var existing = cache.Get(key) as HttpGetResource;
        //    if (!forceRefresh && existing != null && !string.IsNullOrEmpty(existing.Content))
        //    {
        //        if (extendTtl)
        //        {
        //            cache.Set(key, existing, expiration);
        //        }
        //        System.Threading.Interlocked.Increment(ref _hits);
        //        return existing;
        //    }

        //    HttpGetResource created;
        //    try
        //    {
        //        if (url.Contains("api.openrouteservice.org"))
        //        {
        //            var orsKey = ConfigurationManager.AppSettings["ORS_BEARER"] ?? "";
        //            using (var http = new HttpClient())
        //            {
        //                if (!string.IsNullOrEmpty(orsKey))
        //                    http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", orsKey);

        //                string content = http.GetStringAsync(url).Result;
        //                created = new HttpGetResource(url, content);   // <— noul ctor
        //            }
        //        }
        //        else
        //        {
        //            // JCDecaux & altele: GET simplu (ctor-ul existent)
        //            created = new HttpGetResource(url);
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        created = new HttpGetResource(url, $"(Error while fetching: {ex.Message})");
        //    }

        //    // Cache-uim DOAR succesul
        //    if (!string.IsNullOrEmpty(created.Content) && !created.Content.StartsWith("(Error"))
        //        cache.Set(key, created, expiration);

        //    return created;
        //}

        private HttpGetResource GetOrCreate(string rawUrl, DateTimeOffset expiration, bool forceRefresh = false, bool extendTtl = false)
        {
            // normalize URL (inject JCDecaux key if needed)
            var url = AddJcdxKeyIfMissing(rawUrl);

            var cache = MemoryCache.Default;
            var key = $"GET::{url}";

            // 1) HIT din cache
            var existing = cache.Get(key) as HttpGetResource;
            if (!forceRefresh && existing != null && !string.IsNullOrEmpty(existing.Content))
            {
                if (extendTtl)
                    cache.Set(key, existing, expiration);

                System.Threading.Interlocked.Increment(ref _hits);  // contor HIT

                System.Diagnostics.Debug.WriteLine($"[{DateTime.Now:T}] URL HIT  key='{key}' age={(int)(DateTime.UtcNow - existing.CreatedUtc).TotalSeconds}s");
                return existing;
            }

            // 2) MISS → mergem la upstream (HttpGetResource știe ORS Bearer + StatusCode)
            HttpGetResource created;
            try
            {
                System.Diagnostics.Debug.WriteLine($"[{DateTime.Now:T}] URL MISS key='{key}' fetching…");
                created = new HttpGetResource(url);
            }
            catch (Exception ex)
            {
                created = new HttpGetResource(url, $"(Error while fetching: {ex.Message})");
                // atenție: în ctor-ul tău pe excepție setezi StatusCode = -1
            }

            // 3) Cache-uim DOAR succesul (HTTP 200) și contorizăm MISS
            if (created.StatusCode == 200 && !string.IsNullOrEmpty(created.Content))
            {
                cache.Set(key, created, expiration);
                System.Threading.Interlocked.Increment(ref _misses);  // contor MISS real (a trebuit să fetch-uim)
                System.Diagnostics.Debug.WriteLine($"[{DateTime.Now:T}] URL MISS->CACHED key='{key}' ttl={(int)(expiration - DateTimeOffset.UtcNow).TotalSeconds}s len={created.Content.Length}");

            } else
            {
                System.Diagnostics.Debug.WriteLine($"[{DateTime.Now:T}] URL MISS_NO_CACHE key='{key}' status={created.StatusCode}");
            }

            return created;
        }


        public string Get(string url)
        {
            var res = GetOrCreate(url, ObjectCache.InfiniteAbsoluteExpiration, forceRefresh: false);
            return res.Content;
        }

        public string GetWithTtl(string url, double ttlSeconds, bool forceRefresh = false, bool extendTtl = false)
        {
            if (ttlSeconds <= 0) ttlSeconds = 60;
            var expiration = DateTimeOffset.UtcNow.AddSeconds(ttlSeconds);

            var res = GetOrCreate(url, expiration, forceRefresh: forceRefresh, extendTtl: extendTtl);
            return res.Content;
        }

        public string GetWithMeta(string url, double ttlSeconds)
        {
            if (ttlSeconds <= 0) ttlSeconds = 60;
            var expiration = DateTimeOffset.UtcNow.AddSeconds(ttlSeconds);

            var normalized = AddJcdxKeyIfMissing(url);
            var key = $"GET::{normalized}";
            var cache = MemoryCache.Default;

            var hit = cache.Get(key) as HttpGetResource;
            if (hit != null && !string.IsNullOrEmpty(hit.Content))
            {
                var age = (int)Math.Max(0, (DateTime.UtcNow - hit.CreatedUtc).TotalSeconds);
                System.Threading.Interlocked.Increment(ref _hits); // count HIT
                System.Diagnostics.Debug.WriteLine($"[{DateTime.Now:T}] META HIT key='{key}' age={age}s");
                return $"{{\"cache\":\"HIT\",\"key\":\"{Escape(key)}\",\"ageSeconds\":{age},\"length\":{hit.Content.Length}}}";
            }

            var res = GetOrCreate(url, expiration, forceRefresh: false, extendTtl: false);
            var cachedNow = cache.Get(key) as HttpGetResource;
            var cachedLabel = (cachedNow != null) ? "MISS->CACHED" : "MISS_NO_CACHE";
            var len = res.Content == null ? 0 : res.Content.Length;
            return $"{{\"cache\":\"{cachedLabel}\",\"key\":\"{Escape(key)}\",\"length\":{len}}}";
        }

        private static string Escape(string s) => s?.Replace("\\", "\\\\").Replace("\"", "\\\"") ?? "";

        // Method to evict a specific URL from the cache
        public void Evict(string url)
        {
            MemoryCache.Default.Remove($"GET::{AddJcdxKeyIfMissing(url)}");
        }

        // Method to evict a generic key from the cache
        public void EvictGeneric(string key)
        {
            // for generic key "jc:contracts" / "jc:stations:lyon"
            MemoryCache.Default.Remove(key);
        }

        // Method to get cache statistics
        public string Stats()
        {
            // items is the current number of cached objects, not "how many URLs have I ever called".
            var items = MemoryCache.Default.GetCount();
            var hits = System.Threading.Interlocked.Read(ref _hits);
            var misses = System.Threading.Interlocked.Read(ref _misses);
            return $"{{\"hits\":{hits},\"misses\":{misses},\"items\":{items}}}";
        }

    }
}